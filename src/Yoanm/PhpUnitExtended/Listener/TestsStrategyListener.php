<?php
namespace Yoanm\PhpUnitExtended\Listener;

/**
 * @see https://github.com/yoanm/Readme/blob/master/TESTS_STRATEGY.md#rules-strict-mode-fails-if-risky-tests
 * Will convert a risky test regarding following option to failure
 *  =>phpunit process will return a failed result at end
 *
 * List of managed options :
 * - beStrictAboutOutputDuringTests="true" / --report-useless-tests
 * - checkForUnintentionallyCoveredCode="true" / --strict-coverage
 *      => in case forceCoversAnnotation is used, and the test execute code that are not listed by
 *          a @covers or @uses annotations
 * - beStrictAboutTestsThatDoNotTestAnything="true" / --disallow-test-output
 * - beStrictAboutChangesToGlobalState="true" / --strict-global-state
 *
 * @see https://github.com/yoanm/Readme/blob/master/strategy/tests/README.md#rules-real-coverage-risky-tests
 * Risky tests will be managed as not executed tests and so, code coverage generated by them will be removed
 *  => Allow failure based on coverage
 */
class TestsStrategyListener extends \PHPUnit_Framework_BaseTestListener
{
    /**
     * @param \PHPUnit_Framework_Test $test
     * @param \Exception              $e
     * @param float                   $time
     */
    public function addRiskyTest(\PHPUnit_Framework_Test $test, \Exception $e, $time)
    {
        /* Must be PHPUnit_Framework_TestCase instance to have access to "getTestResultObject" method */
        if ($test instanceof \PHPUnit_Framework_TestCase) {
            $testResult = $test->getTestResultObject();
            $reason = null;
            switch (true) {
                /* beStrictAboutOutputDuringTests="true" */
                case $e instanceof \PHPUnit_Framework_OutputError:
                    $reason = 'No output during test';
                    /** Ack - remove coverage */
                    $this->removeCoverageFor($test);
                    /** END Ack */
                    break;
                /* checkForUnintentionallyCoveredCode="true" */
                case $e instanceof \PHPUnit_Framework_UnintentionallyCoveredCodeError:
                    $reason = 'Executed code must be defined with @covers and @uses annotations';
                    break;
                default:
                    if (preg_match('#\-\-\- Global variables before the test#', $e->getMessage())) {
                        /* beStrictAboutChangesToGlobalState="true" (no specific exception) for globals */
                        $reason = 'Global variable manipulation during test';
                    } elseif (preg_match('#\-\-\- Static attributes before the test#', $e->getMessage())) {
                        /* beStrictAboutChangesToGlobalState="true" (no specific exception) for static var */
                        /* Only when beStrictAboutChangesToGlobalState="true" */
                        $reason = 'Static attribute manipulation during test';
                    } elseif (preg_match('#This test did not perform any assertions#', $e->getMessage())) {
                        /* beStrictAboutTestsThatDoNotTestAnything="true" (no specific exception) */
                        $reason = 'Test that do not test anything';
                    }
                    break;
            }
            if (null !== $reason) {
                $testResult->addFailure(
                    $test,
                    new \PHPUnit_Framework_AssertionFailedError(
                        sprintf(
                            "Strict mode - %s :\n%s",
                            $reason,
                            $e->getMessage()
                        )
                    ),
                    $time
                );
            }
        }
    }

    /**
     * @param \PHPUnit_Framework_TestCase $test
     */
    protected function removeCoverageFor(\PHPUnit_Framework_TestCase $test)
    {
        $coverage = $test->getTestResultObject()->getCodeCoverage();
        if (null !== $coverage) {
            $id = sprintf('%s::%s', get_class($test), $test->getName());
            $data = $coverage->getData();
            foreach ($data as $fileName => $lineData) {
                foreach ($lineData as $lineNumber => $testIdList) {
                    if (is_array($testIdList)) {
                        foreach ($testIdList as $testIdKey => $testId) {
                            if ($id === $testId) {
                                unset($data[$fileName][$lineNumber][$testIdKey]);
                            }
                        }
                    }
                }
            }
            $coverage->setData($data);
        }
    }
}
